# -*- coding: utf-8 -*-
"""Project_code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M95kkoWAXE7uiBRHtaGnFRjHv47pXaBM
"""

import yfinance as yf
import pandas as pd
import numpy as np
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import warnings

# Suppress warnings for cleaner output
warnings.filterwarnings("ignore")

# Define stock tickers
tickers = ['NMDC.NS', 'VEDL.NS', 'TATAMOTORS.NS', 'NATIONALUM.NS', 'INDUSTOWER.NS',
           'HEROMOTOCO.NS', 'HINDZINC.NS', 'ACC.NS', 'DRREDDY.NS']

# Define stock display names (same as tickers for simplicity, can be customized if needed)
display_names = ['NMDC', 'Vedanta', 'Tata Motors', 'Natl. Aluminium', 'Indus Towers',
                 'Hero Motocorp', 'Hindustan Zinc', 'ACC', 'Dr Reddy\'s Labs']

def get_stock_data(tickers, start_date="2022-05-12", end_date="2025-05-13"):
    """
    Fetches historical stock data from Yahoo Finance for a list of tickers.

    Args:
        tickers (list): A list of stock ticker symbols (strings).
        start_date (str): Start date in 'YYYY-MM-DD' format. Defaults to May 12, 2022.
        end_date (str): End date in 'YYYY-MM-DD' format. Defaults to May 13, 2025.
    Returns:
        pandas.DataFrame: A pandas DataFrame containing the historical stock data,
                        or None if there is an error. The DataFrame is indexed by date,
                        and contains the closing prices for each stock.
    """
    try:
        data = yf.download(tickers, start=start_date, end=end_date, threads=True)
        if data is None or data.empty:
            print("Error: yfinance.download returned None or empty data.")
            return None
        prices = data['Close']  # Extract closing prices
        print(f"Number of days before dropping NaNs: {len(prices)}")
        prices = prices.dropna()
        print(f"Number of days after dropping NaNs: {len(prices)}")
        # Check if the date range is sufficient
        expected_days = 756  # Approximate trading days in 3 years (252 * 3)
        if len(prices) < expected_days * 0.9:  # Allow 10% missing days
            print(f"Warning: Fetched {len(prices)} days, expected ~{expected_days} days.")
        return prices
    except Exception as e:
        print(f"Error fetching data from Yahoo Finance: {e}")
        return None

def portfolio_performance(weights, returns, cov_matrix, risk_free_rate, trading_days):
    """
    Calculates portfolio performance metrics (return, volatility, Sharpe ratio).

    Args:
        weights (numpy.ndarray): Portfolio weights.
        returns (pandas.DataFrame): Daily returns of assets.
        cov_matrix (pandas.DataFrame): Covariance matrix of asset returns.
        risk_free_rate (float): Annual risk-free rate.
        trading_days (int): Number of trading days in a year.

    Returns:
        tuple: (portfolio_return, portfolio_std, sharpe_ratio)
    """
    portfolio_return = np.sum(returns.mean() * weights) * trading_days
    portfolio_std = np.sqrt(np.dot(weights.T, np.dot(cov_matrix * trading_days, weights)))
    sharpe_ratio = (portfolio_return - risk_free_rate) / portfolio_std
    return portfolio_return, portfolio_std, sharpe_ratio

def neg_sharpe_ratio(weights, returns, cov_matrix, risk_free_rate, trading_days):
    """
    Negative Sharpe ratio for minimization.
    """
    return -portfolio_performance(weights, returns, cov_matrix, risk_free_rate, trading_days)[2]

def optimize_portfolio(returns, cov_matrix, risk_free_rate, trading_days, num_stocks):
    """
    Optimizes portfolio weights to maximize Sharpe ratio.

    Args:
        returns (pandas.DataFrame): Daily returns of assets.
        cov_matrix (pandas.DataFrame): Covariance matrix of asset returns.
        risk_free_rate (float): Annual risk-free rate.
        trading_days (int): Number of trading days in a year.
        num_stocks (int): Number of stocks.

    Returns:
        tuple: (opt_weights, opt_return, opt_std, opt_sharpe, success)
    """
    constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1},)
    bounds = tuple((0, 1) for _ in range(num_stocks))
    init_guess = np.array([1.0 / num_stocks] * num_stocks)  # Use np.array

    opt_result = minimize(
        neg_sharpe_ratio,
        init_guess,
        args=(returns, cov_matrix, risk_free_rate, trading_days),
        method='SLSQP',
        bounds=bounds,
        constraints=constraints,
        options={'maxiter': 1000}  # Increase maxiter
    )

    if opt_result.success:
        opt_weights = opt_result.x
        opt_return, opt_std, opt_sharpe = portfolio_performance(opt_weights, returns, cov_matrix, risk_free_rate, trading_days)
        return opt_weights, opt_return, opt_std, opt_sharpe, True
    else:
        print("Optimization failed:", opt_result.message)
        return np.array([]), 0, 0, 0, False

def main():
    """
    Main function to fetch data, perform portfolio optimization, and display results.
    """
    # Get stock data from Yahoo Finance
    price_data = get_stock_data(tickers)
    if price_data is None:
        print("Exiting due to error fetching data.")
        return

    # Calculate daily returns
    returns = price_data.pct_change().dropna()

    # Portfolio optimization parameters
    num_stocks = len(tickers)
    risk_free_rate = 0.06  # Annual risk-free rate (6%)
    trading_days = 252

    # Debug: Analyze daily returns
    print("\nDaily Returns Statistics:")
    print(returns.describe())
    print("\nDaily Returns Summary (Annualized):")
    print("Expected Annual Returns:")
    print(returns.mean() * trading_days)
    print("\nAnnual Volatility:")
    print(returns.std() * np.sqrt(trading_days))
    print("\nCorrelation Matrix:")
    print(returns.corr())

    # Calculate annualized expected returns and daily covariance matrix
    mean_returns = returns.mean() * trading_days
    cov_matrix = returns.cov()

    # Perform portfolio optimization
    opt_weights, opt_return, opt_std, opt_sharpe, success = optimize_portfolio(returns, cov_matrix, risk_free_rate, trading_days, num_stocks)

    if success:
        # Print results
        print("\nOptimal Portfolio Weights:")
        for stock, weight in zip(display_names, opt_weights):
            print(f"{stock}: {weight:.4f} ({weight * 100:.1f}%)")
        print(f"\nExpected Annual Return: {opt_return:.4f} ({opt_return * 100:.1f}%)")
        print(f"Annual Volatility: {opt_std:.4f} ({opt_std * 100:.1f}%)")
        print(f"Sharpe Ratio: {opt_sharpe:.4f}")

        # Plot portfolio weights
        plt.figure(figsize=(12, 6))
        plt.bar(display_names, opt_weights, color='skyblue')
        plt.title('Optimal Portfolio Weights')
        plt.xlabel('Stocks')
        plt.ylabel('Weight')
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.savefig('optimal_portfolio_weights_yfinance_fixed_date_range.png')
        plt.show()
    else:
        print("Portfolio optimization failed.")

if __name__ == "__main__":
    main()