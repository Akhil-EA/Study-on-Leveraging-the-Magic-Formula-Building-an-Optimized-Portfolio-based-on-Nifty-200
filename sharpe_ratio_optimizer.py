# -*- coding: utf-8 -*-
"""Sharpe ratio optimizer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GTyeN9iMKp21Wf3hiyEIZAcLazoT9Ktx
"""

import yfinance as yf
import pandas as pd
import numpy as np
from scipy.optimize import minimize
from scipy.stats.mstats import winsorize # Import winsorize
import matplotlib.pyplot as plt
import warnings
from datetime import datetime

# Suppress warnings for cleaner output
warnings.filterwarnings("ignore")

def get_stock_data(tickers, start_date, end_date):
    """
    Fetches historical stock data from Yahoo Finance for a list of tickers.

    Args:
        tickers (list): A list of stock ticker symbols (strings).
        start_date (str): Start date in 'YYYY-MM-DD' format.
        end_date (str): End date in 'YYYY-MM-DD' format.
    Returns:
        pandas.DataFrame: A pandas DataFrame containing the historical stock data,
                          or None if there is an error. The DataFrame is indexed by date,
                          and contains the closing prices for each stock.
    """
    try:
        print(f"\nFetching data for tickers: {', '.join(tickers)}")
        print(f"From {start_date} to {end_date}")
        data = yf.download(tickers, start=start_date, end=end_date, threads=True)

        if data is None or data.empty:
            print("Error: yfinance.download returned None or empty data for the specified range.")
            return None

        # Select 'Close' prices for all tickers
        # If only one ticker is fetched, data['Close'] might return a Series, not a DataFrame
        prices = data['Close']
        if isinstance(prices, pd.Series):
            prices = prices.to_frame() # Convert Series to DataFrame for consistency

        print(f"Initial data points before dropping NaNs: {len(prices)}")
        prices = prices.dropna() # Drop rows with any NaN values

        if prices.empty:
            print("Error: No common historical data available for all specified tickers within the date range after dropping NaNs.")
            return None

        print(f"Data points after dropping NaNs: {len(prices)}")

        # Check if the date range is sufficient (optional, but good for user feedback)
        # Approximate trading days in 1 year = 252. Adjust expected_days based on date range duration.
        start_dt = datetime.strptime(start_date, '%Y-%m-%d')
        end_dt = datetime.strptime(end_date, '%Y-%m-%d')
        total_days = (end_dt - start_dt).days
        expected_min_trading_days = max(50, int(total_days * 0.6)) # At least 50 days, or 60% of total days

        if len(prices) < expected_min_trading_days:
            print(f"Warning: Fetched only {len(prices)} days of data, which might be insufficient for robust analysis. Expected at least ~{expected_min_trading_days} trading days for this period.")

        return prices
    except Exception as e:
        print(f"Error fetching data from Yahoo Finance: {e}")
        return None

def portfolio_performance(weights, returns, cov_matrix, risk_free_rate, trading_days):
    """
    Calculates portfolio performance metrics (return, volatility, Sharpe ratio).

    Args:
        weights (numpy.ndarray): Portfolio weights.
        returns (pandas.DataFrame): Daily returns of assets.
        cov_matrix (pandas.DataFrame): Covariance matrix of asset returns.
        risk_free_rate (float): Annual risk-free rate.
        trading_days (int): Number of trading days in a year.

    Returns:
        tuple: (portfolio_return, portfolio_std, sharpe_ratio)
    """
    # Ensure weights are a numpy array and sum to 1
    weights = np.array(weights)
    if np.sum(weights) != 1.0: # This condition might be met if optimization is still running
        weights = weights / np.sum(weights) # Normalize weights if they don't sum to 1 (should be handled by constraints)

    portfolio_return = np.sum(returns.mean() * weights) * trading_days
    portfolio_std = np.sqrt(np.dot(weights.T, np.dot(cov_matrix * trading_days, weights)))
    sharpe_ratio = (portfolio_return - risk_free_rate) / portfolio_std
    return portfolio_return, portfolio_std, sharpe_ratio

def neg_sharpe_ratio(weights, returns, cov_matrix, risk_free_rate, trading_days):
    """
    Negative Sharpe ratio for minimization.
    """
    # Small epsilon to prevent division by zero for portfolio_std
    epsilon = 1e-6
    port_return, port_std, _ = portfolio_performance(weights, returns, cov_matrix, risk_free_rate, trading_days)
    if port_std <= epsilon: # Avoid division by zero or very small std
        return float('inf') # Return a very large number to penalize zero/near-zero volatility portfolios

    return -(port_return - risk_free_rate) / port_std

def optimize_portfolio(returns, cov_matrix, risk_free_rate, trading_days, num_stocks):
    """
    Optimizes portfolio weights to maximize Sharpe ratio.

    Args:
        returns (pandas.DataFrame): Daily returns of assets.
        cov_matrix (pandas.DataFrame): Covariance matrix of asset returns.
        risk_free_rate (float): Annual risk-free rate.
        trading_days (int): Number of trading days in a year.
        num_stocks (int): Number of stocks.

    Returns:
        tuple: (opt_weights, opt_return, opt_std, opt_sharpe, success)
    """
    if num_stocks == 0:
        print("Error: No stocks to optimize.")
        return np.array([]), 0, 0, 0, False
    if returns.empty:
        print("Error: Returns data is empty.")
        return np.array([]), 0, 0, 0, False

    constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1},) # Weights must sum to 1
    bounds = tuple((0, 1) for _ in range(num_stocks)) # Weights must be between 0 and 1 (no short selling)
    init_guess = np.array([1.0 / num_stocks] * num_stocks) # Initial guess: equally weighted portfolio

    print("\nAttempting portfolio optimization...")
    opt_result = minimize(
        neg_sharpe_ratio,
        init_guess,
        args=(returns, cov_matrix, risk_free_rate, trading_days),
        method='SLSQP', # Sequential Least Squares Programming
        bounds=bounds,
        constraints=constraints,
        options={'maxiter': 2000, 'ftol': 1e-9} # Increased maxiter and set ftol for better convergence
    )

    if opt_result.success:
        opt_weights = opt_result.x
        opt_return, opt_std, opt_sharpe = portfolio_performance(opt_weights, returns, cov_matrix, risk_free_rate, trading_days)
        return opt_weights, opt_return, opt_std, opt_sharpe, True
    else:
        print("Optimization failed:", opt_result.message)
        return np.array([]), 0, 0, 0, False

def main():
    """
    Main function to get user input, fetch data, perform portfolio optimization, and display results.
    """
    print("--- Stock Portfolio Optimizer ---")

    # Get user input for tickers
    while True:
        ticker_input = input("Enter stock tickers (comma-separated, e.g., NMDC.NS,VEDL.NS): ").strip()
        if ticker_input:
            tickers = [t.strip() for t in ticker_input.split(',')]
            # Filter out any empty strings that might result from extra commas
            tickers = [t for t in tickers if t]
            if tickers: # Check if the list is not empty after filtering
                break
            else:
                print("Invalid input. Please enter valid ticker symbols separated by commas.")
        else:
            print("Ticker input cannot be empty. Please try again.")

    # Get user input for dates
    while True:
        start_date = input("Enter start date (YYYY-MM-DD, e.g., 2022-01-01): ").strip()
        end_date = input("Enter end date (YYYY-MM-DD, e.g., 2025-01-01): ").strip()
        try:
            dt_start = datetime.strptime(start_date, '%Y-%m-%d')
            dt_end = datetime.strptime(end_date, '%Y-%m-%d')
            if dt_start >= dt_end:
                print("Start date must be before end date. Please try again.")
            else:
                break
        except ValueError:
            print("Invalid date format. Please use YYYY-MM-DD.")

    # Use tickers as display names, optionally stripping '.NS' for cleaner output
    display_names = [t.replace('.NS', '') for t in tickers]

    # Get stock data from Yahoo Finance
    price_data = get_stock_data(tickers, start_date, end_date)
    if price_data is None or price_data.empty:
        print("Exiting due to error or insufficient data fetching.")
        return

    # Ensure price_data columns match the order of tickers that were successfully fetched
    # This handles cases where yfinance might not return data for all requested tickers
    successful_tickers = [t for t in tickers if t in price_data.columns]
    if not successful_tickers:
        print("No data fetched for any of the provided tickers. Exiting.")
        return

    price_data = price_data[successful_tickers]
    tickers = successful_tickers # Update tickers list to only include those with data
    display_names = [t.replace('.NS', '') for t in tickers] # Update display names

    # Calculate daily returns
    if len(price_data) < 2:
        print("Not enough data points to calculate returns after cleaning. Need at least 2 days of data.")
        return

    returns = price_data.pct_change().dropna()

    if returns.empty:
        print("Error: No valid daily returns could be calculated. This might mean only one day of data was available or all returns were NaN.")
        return

    # --- Outlier Handling: Apply Winsorization to returns ---
    # Define the limits for winsorization (e.g., 1% from both ends)
    # Adjust these limits based on how aggressive you want the outlier treatment to be.
    winsorization_limits = [0.01, 0.01] # Cap values outside 1st and 99th percentile

    print(f"\nApplying Winsorization to returns with limits: {winsorization_limits[0]*100}% lower and {winsorization_limits[1]*100}% upper percentiles.")
    winsorized_returns = returns.copy()
    for col in winsorized_returns.columns:
        # Check if the column has enough data points to apply winsorize
        if len(winsorized_returns[col]) > int(1 / (winsorization_limits[0] + winsorization_limits[1])):
            winsorized_returns[col] = winsorize(winsorized_returns[col], limits=winsorization_limits)
        else:
            print(f"Skipping Winsorization for {col} due to insufficient data points ({len(winsorized_returns[col])}).")

    returns = winsorized_returns # Overwrite returns with the winsorized version
    # --------------------------------------------------------

    # Portfolio optimization parameters
    num_stocks = len(tickers)
    risk_free_rate = 0.06  # Annual risk-free rate (6%) - you can adjust this
    trading_days = 252     # Standard number of trading days in a year

    # Ensure cov_matrix can be calculated (needs at least as many observations as stocks for non-singular matrix)
    if len(returns) < num_stocks:
        print(f"Warning: Not enough daily return observations ({len(returns)}) to reliably calculate covariance matrix for {num_stocks} stocks. Results might be inaccurate.")
        # Attempt to proceed, but results might be unstable

    # Calculate annualized expected returns and daily covariance matrix
    # Using the mean of daily returns to annualize
    mean_returns = returns.mean() * trading_days
    cov_matrix = returns.cov()

    # Debug: Analyze daily returns (optional, for detailed inspection)
    print("\n--- Daily Returns Statistics (After Winsorization) ---")
    print(returns.describe())
    print("\n--- Annualized Returns and Volatility (After Winsorization) ---")
    print("Expected Annual Returns:")
    print(mean_returns)
    print("\nAnnual Volatility (Standard Deviation):")
    print(returns.std() * np.sqrt(trading_days))
    print("\n--- Correlation Matrix (After Winsorization) ---")
    print(returns.corr())
    print("-" * 30)

    # Perform portfolio optimization
    opt_weights, opt_return, opt_std, opt_sharpe, success = optimize_portfolio(returns, cov_matrix, risk_free_rate, trading_days, num_stocks)

    if success:
        # Print results
        print("\n--- Optimal Portfolio Results ---")
        print("Optimal Portfolio Weights:")
        # Display weights, handling cases where optimization might return weights for fewer stocks
        for i, (stock, weight) in enumerate(zip(display_names, opt_weights)):
            print(f"{stock} ({tickers[i]}): {weight:.4f} ({weight * 100:.1f}%)")
        print(f"\nExpected Annual Return: {opt_return:.4f} ({opt_return * 100:.1f}%)")
        print(f"Annual Volatility: {opt_std:.4f} ({opt_std * 100:.1f}%)")
        print(f"Sharpe Ratio: {opt_sharpe:.4f}")
        print("-" * 30)

        # Plot portfolio weights
        plt.figure(figsize=(12, 6))
        # Filter out stocks with effectively zero weights for cleaner plot if desired,
        # but for now, plot all
        plt.bar(display_names, opt_weights, color='skyblue')
        plt.title('Optimal Portfolio Weights', fontsize=16)
        plt.xlabel('Stocks', fontsize=12)
        plt.ylabel('Weight', fontsize=12)
        plt.xticks(rotation=45, ha='right', fontsize=10) # Rotate for long names
        plt.yticks(fontsize=10)
        plt.grid(axis='y', linestyle='--', alpha=0.7)
        plt.tight_layout() # Adjust layout to prevent labels from being cut off
        plt.savefig('optimal_portfolio_weights_flexible.png')
        plt.show()
    else:
        print("Portfolio optimization failed. Please check your inputs and data availability.")

if __name__ == "__main__":
    main()